 **<p style="text-align: center;"> РОССИЙСКИЙ УНИВЕРСИТЕТ ДРУЖБЫ НАРОДОВ  
 Факультет физико-математических и естественных наук  
Кафедра прикладной информатики и теории вероятностей**  
  
    

**<p style="text-align: center;">ОТЧЕТ  
ПО ЛАБОРАТОРНОЙ РАБОТЕ № 14**

<p style="text-align: center;"><ins>Средства, применяемые при
разработке программного обеспечения в ОС типа UNIX/Linux</ins></p>    
  
  
<ins>Студент: Тасыбаева Наталья Сергеевна

Группа: НПИбд-02-20</ins>  

МОСКВА 2021г.  


**<p style="text-align: center;">Цель работы:** <ins> Приобрести простейшие навыки разработки, анализа, тестирования и отладки
приложений в ОС типа UNIX/Linux на примере создания на языке программирования С калькулятора с простейшими функциями.




**<p style="text-align: center;">Ход работы:**  

1. В домашнем каталоге я создала подкаталог ~/work/os/lab_prog (рис.1)
><img src="lab14_zad1.png"> рис.1 

2. Создала в нём файлы: calculate.h, calculate.c, main.c (рис.2)
> <img src="lab14_zad2.png">рис.2 

Это будет примитивнейший калькулятор, способный складывать, вычитать,
умножать и делить, возводить число в степень, брать квадратный корень, вычислять sin, cos, tan. При запуске он будет запрашивать первое число, операцию,
второе число. После этого программа выведет результат и остановится.

3. Код файла calculate.c: (рис.3)
><img src="lab14_zad2_cc.png">рис.3
4. Код файла calculate.h: (рис.4)
><img src="lab14_zad2_ch.png">рис.4
5. Код файла main.c: (рис.5)
><img src="lab14_zad2_mc.png">рис.5

6. Выполнила компиляцию программы посредством gcc: (рис.6)
 > <img src="lab14_zad3.png"> рис.6 
 
7. Создала Makefile со следующим содержанием: (рис.7)
 ><img src="lab14_zad45.png"> рис.7
8. Запустила отладчик GDB, загрузив в него программу для отладки:
gdb ./calcul (рис.8)
  ><img src="lab14_zad6_gdb.png"> рис.8
9. Для запуска программы внутри отладчика ввела команду run: скриешот я забыла сделать, но в скринкасте видно, что команда run работает.
10.  Далее все команды, котороые с оператором list в моём терминале не работает. (рис.9)
 ><img src="lab14_zad6_list.png"> рис.9
 

**<p style="text-align: center;">Вывод:**   
Я приобрела простейшие навыки разработки, анализа, тестирования и отладки
приложений в ОС типа UNIX/Linux на примере создания на языке программирования С калькулятора с простейшими функциями.

**<p style="text-align: center;">Ответы на контрольные вопросы:**
1. Как получить информацию о возможностях программ gcc, make, gdb и др.?

Воспользоваться интернетом, воспользоваться командой man, info

2. Назовите и дайте краткую характеристику основным этапам разработки приложений в UNIX.

Unix поддерживает следующие основные этапы разработки приложений:

-создание исходного кода программы;

-сохранение различных вариантов исходного текста;

-анализ исходного текста; Необходимо отслеживать изменения исходного кода, а также при работе более двух программистов над проектом программы нужно, чтобы они не делали изменений кода в одно время.

-компиляция исходного текста и построение исполняемого модуля

-тестирование и отладка;

-сохранение всех изменений, выполняемых при тестировании и отладке.

3. Что такое суффикс в контексте языка программирования? Приведите примеры использования.

Использование суффикса ".с" для имени файла с программой на языке Си отражает удобное и полезное соглашение, принятое в ОС UNIX. Для любого имени входного файла суффикс определяет какая компиляция требуется. Суффиксы и префиксы указывают тип объекта. Одно из полезных свойств компилятора Си — его способность по суффиксам определять типы файлов. По суффиксу .c компилятор распознает, что файл abcd.c должен компилироваться, а по суффиксу .o, что файл abcd.о является объектным модулем и для получения исполняемой программы необходимо выполнить редактирование связей. Простейший пример командной строки для компиляции программы abcd.c и построения исполняемого модуля abcd имеет вид: gcc -o abcd abcd.c.

4. Каково основное назначение компилятора языка С в UNIX?

В компиляции всей программы в целом и получении исполняемого модуля.

5. Для чего предназначена утилита make?

Для упрощения и автоматизации работы пользователя с командной строкой

6. Приведите пример структуры Makefile. Дайте характеристику основным элементам этого файла.

Текст, следующий за точкой с запятой, и все последующие строки, начинающиеся с литеры табуляции, являются командами OC UNIX, которые необходимо выполнить для обновления целевого файла. Таким образом, спецификация взаимосвязей имеет формат:

target1 [ target2...]: [:] [dependment1...]

[(tab)commands]

[#commentary]

[(tab)commands]

[#commentary],

где # — специфицирует начало комментария; : — последовательность команд ОС UNIX должна содержаться в одной строке make-файла (файла описаний), есть возможность переноса команд (\), но она считается как одна строка; :: — последовательность команд ОС UNIX может содержаться в нескольких последовательных строках файла описаний.

7. Назовите основное свойство, присущее всем программам отладки. Что необходимо сделать, чтобы его можно было использовать?

Все программы отладки позволяют отслеживать состояние программы на любом из этапов ее исполнения. Для того чтобы эту возможность использовать необходимо изучить документацию по использованию определенного отладчика. Понять общие принципы отладки.

8. Назовите и дайте основную характеристику основным командам отладчика gdb.

– backtrace – выводит весь путь к текущей точке останова, то есть

названия всех функций, начиная от main(); иными словами, выводит

весь стек функций;

– break – устанавливает точку останова; параметром может быть

номер строки или название функции;

– clear – удаляет все точки останова на текущем уровне стека (то есть

в текущей функции);

– continue – продолжает выполнение программы от текущей точки

до конца;

– delete – удаляет точку останова или контрольное выражение;

– display – добавляет выражение в список выражений, значения кото-

рых отображаются каждый раз при остановке программы;

– finish – выполняет программу до выхода из текущей функции; отоб-

ражает возвращаемое значение,если такое имеется;

– info breakpoints – выводит список всех имеющихся точек останова;

– info watchpoints – выводит список всех имеющихся контрольных

выражений;

– list – выводит исходный код; в качестве параметра передаются

название файла исходного кода, затем, через двоеточие, номер

начальной и конечной строки;

– next – пошаговое выполнение программы, но, в отличие от команды

step, не выполняет пошагово вызываемые функции;

– print – выводит значение какого-либо выражения (выражение пере-

даётся в качестве параметра);

– run – запускает программу на выполнение;

– set – устанавливает новое значение переменной

– step – пошаговое выполнение программы;

– watch – устанавливает контрольное выражение, программа остановится, как только значение контрольного выражения изменится;
9. Опишите по шагам схему отладки программы, которую Вы использовали при выполнении лабораторной работы.

Сначала я запустил отладчик для моей программы. Установил интересующую меня точку остановки. Запустил программу ожидая, что программа остановится на точке остановки. Узнал необходимые данные моей программы на текущем этапе ее исполнения путем ввода команд. Отобразил данные. Завершил программу, снял точки остановки.

10. Прокомментируйте реакцию компилятора на синтаксические ошибки в программе при его первом запуске.

В моем случае не было синтаксических ошибок. Были ошибки семантические. Компилятор

начал жаловаться на то, что программа по смыслу принимает указатель на char массив. В то время как я вводил не указатель, а прямое значение . Ошибка была исправлена

11. Назовите основные средства, повышающие понимание исходного кода программы.

- cscope - исследование функций, содержащихся в программе;

- lint -- критическая проверка программ, написанных на языке Си.

12. Каковы основные задачи, решаемые программой splint?

Splint- инструмент для статической проверки C-программ на наличие уязвимостей и ошибок